;;; fgd-gen.el --- Generate .fgd from program .dat files -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Alex
;; Version: 0.0
;; Package-Requires: ((emacs "24.3") (cl-lib "0.5"))
;;
;;; Commentary:
;;
;; Extracts @fgd blocks from program .dat files referenced by progs.src,
;; writes a .fgd (using the sole .fmf in the active dir or parent dir),
;; then improves class syntax by moving top-matter from bodies into headers,
;; normalizing whitespace, indenting bodies, and ensuring balanced brackets.
;;
;;; Code:

(require 'cl-lib)

;; -------------------------------------------------------------------
;; low-level helpers
;; -------------------------------------------------------------------

(defun fgd-gen--read-file-as-bytes (file)
  "Return FILE contents as a unibyte string (literal bytes)."
  (with-temp-buffer
    (set-buffer-multibyte nil)
    (insert-file-contents-literally file)
    (buffer-string)))

(defun fgd-gen--write-text-file (file text)
  "Write TEXT to FILE using a multibyte buffer (normal text file)."
  (with-temp-file file
    (set-buffer-multibyte t)
    (insert text)))

(defun fgd-gen--escaped-p (string pos)
  "Return t if character at POS in STRING is escaped by odd number of backslashes."
  (let ((i (1- pos))
        (count 0))
    (while (and (>= i 0) (eq (aref string i) ?\\))
      (setq count (1+ count))
      (setq i (1- i)))
    (= (mod count 2) 1)))

(defun fgd-gen--find-first-unquoted (string char &optional start)
  "Return index of CHAR in STRING at or after START that is not inside double quotes.
If not found, return nil. START defaults to 0.

This treats `\"` as an escaped quote and ignores characters inside double-quoted strings."
  (let* ((len (length string))
         (i (or start 0))
         (in-quote nil))
    (while (< i len)
      (let ((c (aref string i)))
        (cond
         ((eq c ?\")                        ; toggle quote (unless escaped)
          (unless (fgd-gen--escaped-p string i)
            (setq in-quote (not in-quote))))
         ((and (not in-quote) (eq c char))
          (cl-return-from fgd-gen--find-first-unquoted i))))
      (setq i (1+ i)))
    nil))

;; -------------------------------------------------------------------
;; locate files (fmf / progs.src)
;; -------------------------------------------------------------------

(defun fgd-gen--find-fmf-file (active-file)
  "Return the single .fmf file found in ACTIVE-FILE's directory or its parent.
Signal an error if none found or if more than one is found."
  (let* ((dir (file-name-directory active-file))
         (parent (expand-file-name ".." dir))
         (candidates (append (directory-files dir t "\\.fmf\\'")
                             (directory-files parent t "\\.fmf\\'"))))
    (setq candidates (cl-remove-if-not #'file-regular-p candidates))
    (cond
     ((null candidates) (error "No .fmf file found in %s or %s" dir parent))
     ((> (length candidates) 1) (error "Multiple .fmf files found; expected one: %S" candidates))
     (t (car candidates)))))

(defun fgd-gen--find-progs-src (active-file)
  "Return path to progs.src.
1) Look in active-file's directory.
2) If not found, search one level down (non-recursively) for a single progs.src.
Signal an error if none or multiple candidates."
  (let* ((base-dir (file-name-directory active-file))
         (primary (expand-file-name "progs.src" base-dir)))
    (cond
     ((file-exists-p primary) primary)
     (t
      (let* ((subs (cl-remove-if-not
                    (lambda (d)
                      (and (file-directory-p d)
                           (not (member (file-name-nondirectory d) '("." "..")))))
                    (directory-files base-dir t)))
             (found
              (cl-loop for d in subs
                       for candidate = (expand-file-name "progs.src" d)
                       if (file-exists-p candidate)
                       collect candidate)))
        (cond
         ((null found) (error "progs.src not found in %s or its immediate subdirectories" base-dir))
         ((> (length found) 1) (error "Multiple progs.src found: %S" found))
         (t (car found)))))))

;; -------------------------------------------------------------------
;; progs.src parsing
;; -------------------------------------------------------------------

(defun fgd-gen--detect-progs-src-type (file)
  "Detect progs.src FILE type.

Return a cons (TYPE . PAYLOAD):
- TYPE 2: PAYLOAD is list of sourcefile names discovered by `#pragma sourcefile`.
- TYPE 1: PAYLOAD is the first-line path string."
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (let ((first-line (string-trim (or (thing-at-point 'line t) ""))))
      (if (string-match "^#pragma[ \t]+sourcefile[ \t]+\\(.+\\)$" first-line)
          (let (files)
            (goto-char (point-min))
            (while (re-search-forward "^#pragma[ \t]+sourcefile[ \t]+\\(.+\\)$" nil t)
              (push (match-string 1) files))
            (cons 2 (nreverse files)))
        (cons 1 first-line)))))

(defun fgd-gen--sourcefiles-to-program-files (type payload base-dir)
  "Convert progs.src TYPE/PAYLOAD to list of absolute program file paths (.dat).

- If TYPE is 2, PAYLOAD is list of .src files which themselves contain program file paths (one per line).
- If TYPE is 1, PAYLOAD is single program file path."
  (cl-case type
    (2
     (cl-loop for src in payload
              append
              (let ((src-path (expand-file-name src base-dir)))
                (unless (file-exists-p src-path)
                  (error "Sourcefile not found: %s" src-path))
                (with-temp-buffer
                  (insert-file-contents src-path)
                  (let (collected)
                    (goto-char (point-min))
                    (while (not (eobp))
                      (let ((line (string-trim (or (thing-at-point 'line t) ""))))
                        (forward-line 1)
                        (unless (or (string-empty-p line) (string-prefix-p "#" line))
                          (push (expand-file-name line (file-name-directory src-path)) collected))))
                    (nreverse collected))))))
    (1
     (let ((dat (expand-file-name payload base-dir)))
       (unless (file-exists-p dat)
         (error "Program file not found: %s" dat))
       (list dat)))))

;; -------------------------------------------------------------------
;; extract @fgd blocks from program .dat files
;; -------------------------------------------------------------------

(defun fgd-gen--extract-fgd-blocks (program-file)
  "Return a list of strings extracted from PROGRAM-FILE.

Each string corresponds to the data between an \"@fgd\" marker and the following NUL (\\0).
The function is defensive and always advances; if a block is incomplete (no NUL), it stops scanning that file."
  (let* ((raw (fgd-gen--read-file-as-bytes program-file))
         (len (length raw))
         (start 0)
         (results '()))
    (while (and start (< start len))
      (let ((pos (string-match "@fgd ?" raw start)))
        (if (not pos)
            (setq start nil)
          (let* ((after (match-end 0))
                 (nil-pos (string-match "\0" raw after)))
            (if (not nil-pos)
                ;; incomplete block, stop scanning this file
                (setq start nil)
              (push (substring raw after nil-pos) results)
              ;; make strict forward progress
              (setq start (max (1+ nil-pos) (1+ pos))))))))
    (nreverse results)))

;; -------------------------------------------------------------------
;; class processing: move top-matter, format body, fix brackets
;; -------------------------------------------------------------------

(defun fgd-gen--normalize-space (s)
  "Trim S and collapse runs of whitespace within to a single space."
  (replace-regexp-in-string "[ \t\n\r]+" " " (string-trim s)))

(defun fgd-gen--process-single-class (class-text)
  "Process CLASS-TEXT and return transformed class text.

- Move first occurrences of model(...), base(...), color(...), size(...)
  from the body into the header if the header doesn't already contain them.
- Preserve multi-line header.
- Keep brackets inside quoted strings ignored when detecting header/body.
- Normalize internal whitespace, indent body lines by two spaces,
  ensure an indented opening '[' line and a matching indented closing ']' line."
  (let* ((wanted '("model" "base" "color" "size"))
         (bracket-pos (fgd-gen--find-first-unquoted class-text ?\[ 0))
         (header (if bracket-pos
                     (string-trim-right (substring class-text 0 bracket-pos))
                   (string-trim-right class-text)))
         (body (if bracket-pos
                   (substring class-text (1+ bracket-pos) (length class-text))
                 ""))
         ;; tokens already present in header (names)
         (header-has
          (cl-remove-if-not
           #'identity
           (cl-mapcar (lambda (name)
                        (when (string-match (concat "\\_<" (regexp-quote name) "\\_>\\s-*(") header)
                          name))
                      wanted)))
         (found-tokens '()))

    ;; Extract first occurrences of wanted tokens from the body
    (when (not (string-empty-p (string-trim body)))
      (with-temp-buffer
        (insert body)
        (goto-char (point-min))
        ;; Search for tokens by name; when found, capture until next ')' and delete it.
        ;; Only keep first occurrence per name and skip names present in header.
        (while (re-search-forward "\\_<\\(model\\|base\\|color\\|size\\)\\_>\\s-*(" nil t)
          (let* ((name (match-string 1))
                 (start (match-beginning 0)))
            ;; find matching ')' - simple heuristic: next ')' character (we assume balanced usage inside)
            (if (re-search-forward "\\)" nil t)
                (let ((end (point)))
                  ;; If header already has name or we already found it, skip capturing
                  (unless (or (member name header-has) (member name found-tokens))
                    (let ((token (string-trim (buffer-substring-no-properties start end))))
                      (push token found-tokens)))
                  ;; delete region and tidy up whitespace/empty lines
                  (goto-char start)
                  (delete-region start end)
                  (delete-horizontal-space)
                  ;; remove possible leftover blank line
                  (when (and (looking-at "^[ \t]*$")
                             (< (point) (point-max)))
                    (let ((lb (line-beginning-position))
                          (le (line-end-position)))
                      (delete-region lb (1+ le))))
                  (goto-char (max 1 start)))
              ;; no closing paren - avoid infinite loop by moving past start
              (goto-char (1+ start))))))
        (setq body (string-trim (buffer-string)))
        (setq found-tokens (nreverse found-tokens)))))

    ;; Build insertion tokens excluding those that header already had
    (let* ((tokens-to-insert
            (cl-remove-if
             (lambda (tok)
               (let ((name (car (split-string tok "("))))
                 (member name header-has)))
             found-tokens))
           (tokens-str (when tokens-to-insert
                         (mapconcat #'fgd-gen--normalize-space tokens-to-insert " "))))

      ;; Insert tokens before first unquoted '=' in header, or append to end
      (let ((new-header header))
        (when (and tokens-str (not (string-empty-p tokens-str)))
          (let ((eq-pos (fgd-gen--find-first-unquoted new-header ?= 0)))
            (if (null eq-pos)
                (setq new-header (concat (string-trim-right new-header) " " tokens-str))
              ;; find line start containing eq-pos
              (let* ((line-start (let ((p eq-pos))
                                   (while (and (> p 0) (not (eq (aref new-header (1- p)) ?\n)))
                                     (setq p (1- p)))
                                   p))
                     (line-end (or (string-match "\n" new-header line-start) (length new-header)))
                     (line-text (string-trim (substring new-header line-start line-end))))
                (if (string-match-p "^=" (string-trim-left line-text))
                    ;; '=' is the first non-space on its line -> append tokens to previous non-empty header line
                    (let ((prev-end (1- line-start)))
                      (if (< prev-end 0)
                          (setq new-header (concat (substring new-header 0 eq-pos) " " tokens-str (substring new-header eq-pos)))
                        (let ((prev-start
                               (let ((p prev-end))
                                 (while (and (>= p 0) (eq (aref new-header p) ?\n))
                                   (setq p (1- p)))
                                 (while (and (>= p 0) (not (eq (aref new-header p) ?\n)))
                                   (setq p (1- p)))
                                 (1+ p))))
                          (setq new-header
                                (concat (substring new-header 0 prev-start)
                                        (string-trim-right (substring new-header prev-start line-start))
                                        " "
                                        tokens-str
                                        (substring new-header line-start))))))
                  ;; '=' inline -> put tokens before it
                  (setq new-header (concat (substring new-header 0 eq-pos) " " tokens-str (substring new-header eq-pos))))))))

        ;; Normalize header internal whitespace but preserve newlines
        (setq new-header (replace-regexp-in-string "[ \t]+" " " new-header))
        (setq new-header (replace-regexp-in-string " \\(\n\\)" "\\1" new-header))
        (setq new-header (replace-regexp-in-string "\\(\n\\) " "\\1" new-header))

        ;; Prepare body -> indent lines, ensure bracket lines, ensure closing bracket
        (let* ((body-lines (if (string-empty-p (string-trim body))
                               nil
                             (split-string body "\n" t)))
               (indented-body (if body-lines
                                  (mapconcat (lambda (ln) (concat "  " (string-trim-right ln))) body-lines "\n")
                                ""))
               (has-close (and bracket-pos (fgd-gen--find-first-unquoted class-text ?\] (1+ (or bracket-pos 0)))))
               (assembled
                (if (string-empty-p indented-body)
                    ;; no body content -> return header only
                    (string-trim-right new-header)
                  ;; body exists -> ensure opening bracket line and a single closing bracket at end
                  (let ((built (concat (string-trim-right new-header) "\n  [\n" indented-body)))
                    (unless has-close
                      (setq built (concat built "\n  ]")))
                    ;; Always normalize to have a single closing bracket line at the end
                    (setq built (concat (string-trim-right built) "\n  ]"))
                    built))))
          assembled)))))

;; -------------------------------------------------------------------
;; apply improvement to .fgd file: find classes and process them
;; -------------------------------------------------------------------

(defun fgd-gen--improve-fgd-syntax (fgd-file)
  "Read FGD-FILE, process each class region, overwrite file, and return new content."
  (let* ((text (with-temp-buffer (insert-file-contents fgd-file) (buffer-string)))
         (class-re "\\(?:^\\|\\n\\)\\s-*@[ \t]*\\(BaseClass\\|PointClass\\|SolidClass\\)\\_>")
         (pos 0)
         (matches '()))
    ;; collect start indices of classes
    (while (and (< pos (length text))
                (string-match class-re text pos))
      (push (match-beginning 0) matches)
      (setq pos (1+ (match-beginning 0))))
    (setq matches (nreverse matches))
    (if (null matches)
        ;; no classes; write text back unchanged and return it
        (progn
          (fgd-gen--write-text-file fgd-file text)
          text)
      ;; otherwise build regions from starts
      (let ((regions '()))
        (dotimes (i (length matches))
          (let* ((s (nth i matches))
                 (e (if (< i (1- (length matches))) (nth (1+ i) matches) (length text))))
            (push (cons s e) regions)))
        (setq regions (nreverse regions))
        ;; assemble output
        (let ((out "")
              (cursor 0))
          (dolist (reg regions)
            (let ((s (car reg)) (e (cdr reg)))
              (setq out (concat out (substring text cursor s)))
              (let ((class-text (substring text s e)))
                (setq out (concat out (fgd-gen--process-single-class class-text))))
              (setq cursor e)))
          (setq out (concat out (substring text (or (cadr (last regions)) (point-min)) (length text))))
          ;; write back and return
          (fgd-gen--write-text-file fgd-file out)
          out))))


;; -------------------------------------------------------------------
;; Main interactive entry point
;; -------------------------------------------------------------------

;;;###autoload
(defun fgd-gen-generate ()
  "Generate a .fgd file from program files referenced by progs.src and improve its syntax.
Run this from a buffer visiting a file inside the project."
  (interactive)
  (unless buffer-file-name
    (user-error "Must run from a visiting file buffer"))
  (let* ((active-file buffer-file-name)
         (base-dir (file-name-directory active-file))
         (fmf (fgd-gen--find-fmf-file active-file))
         (fgd (concat (file-name-sans-extension fmf) ".fgd"))
         (progs-src (fgd-gen--find-progs-src active-file)))
    (pcase-let* ((`(,type . ,payload) (fgd-gen--detect-progs-src-type progs-src))
                 (program-files (fgd-gen--sourcefiles-to-program-files type payload base-dir)))
      (let (blocks)
        (dolist (pf program-files)
          (setq blocks (append blocks (fgd-gen--extract-fgd-blocks pf))))
        ;; write raw fgd (concatenate blocks without adding newlines)
        (fgd-gen--write-text-file fgd (mapconcat #'identity blocks ""))
        ;; improve syntax in-place
        (let ((new-content (fgd-gen--improve-fgd-syntax fgd)))
          (with-help-window "*FGD Output*"
            (with-current-buffer standard-output
              (insert new-content)
              (goto-char (point-min))))
          (message "FGD written and improved: %s" fgd))))))

(provide 'fgd-gen)
;;; fgd-gen.el ends here
